diff --git a/expo-sqlite/driver.cjs.map b/expo-sqlite/driver.cjs.map
index 275d210894f972f915827030491ac6b19d564344..2d0c5d5c1574a2f1da284187e56ca72dcd001231 100644
--- a/expo-sqlite/driver.cjs.map
+++ b/expo-sqlite/driver.cjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/expo-sqlite/driver.ts"],"sourcesContent":["import type { SQLiteDatabase, SQLiteRunResult } from 'expo-sqlite/next';\nimport { entityKind } from '~/entity.ts';\nimport { DefaultLogger } from '~/logger.ts';\nimport {\n\tcreateTableRelationsHelpers,\n\textractTablesRelationalConfig,\n\ttype RelationalSchemaConfig,\n\ttype TablesRelationalConfig,\n} from '~/relations.ts';\nimport { BaseSQLiteDatabase } from '~/sqlite-core/db.ts';\nimport { SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport type { DrizzleConfig } from '~/utils.ts';\nimport { ExpoSQLiteSession } from './session.ts';\n\nexport class ExpoSQLiteDatabase<TSchema extends Record<string, unknown> = Record<string, never>>\n\textends BaseSQLiteDatabase<'sync', SQLiteRunResult, TSchema>\n{\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteDatabase';\n}\n\nexport function drizzle<TSchema extends Record<string, unknown> = Record<string, never>>(\n\tclient: SQLiteDatabase,\n\tconfig: DrizzleConfig<TSchema> = {},\n): ExpoSQLiteDatabase<TSchema> & {\n\t$client: SQLiteDatabase;\n} {\n\tconst dialect = new SQLiteSyncDialect({ casing: config.casing });\n\tlet logger;\n\tif (config.logger === true) {\n\t\tlogger = new DefaultLogger();\n\t} else if (config.logger !== false) {\n\t\tlogger = config.logger;\n\t}\n\n\tlet schema: RelationalSchemaConfig<TablesRelationalConfig> | undefined;\n\tif (config.schema) {\n\t\tconst tablesConfig = extractTablesRelationalConfig(\n\t\t\tconfig.schema,\n\t\t\tcreateTableRelationsHelpers,\n\t\t);\n\t\tschema = {\n\t\t\tfullSchema: config.schema,\n\t\t\tschema: tablesConfig.tables,\n\t\t\ttableNamesMap: tablesConfig.tableNamesMap,\n\t\t};\n\t}\n\n\tconst session = new ExpoSQLiteSession(client, dialect, schema, { logger });\n\tconst db = new ExpoSQLiteDatabase('sync', dialect, session, schema) as ExpoSQLiteDatabase<TSchema>;\n\t(<any> db).$client = client;\n\n\treturn db as any;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,oBAA2B;AAC3B,oBAA8B;AAC9B,uBAKO;AACP,gBAAmC;AACnC,qBAAkC;AAElC,qBAAkC;AAE3B,MAAM,2BACJ,6BACT;AAAA,EACC,QAA0B,wBAAU,IAAY;AACjD;AAEO,SAAS,QACf,QACA,SAAiC,CAAC,GAGjC;AACD,QAAM,UAAU,IAAI,iCAAkB,EAAE,QAAQ,OAAO,OAAO,CAAC;AAC/D,MAAI;AACJ,MAAI,OAAO,WAAW,MAAM;AAC3B,aAAS,IAAI,4BAAc;AAAA,EAC5B,WAAW,OAAO,WAAW,OAAO;AACnC,aAAS,OAAO;AAAA,EACjB;AAEA,MAAI;AACJ,MAAI,OAAO,QAAQ;AAClB,UAAM,mBAAe;AAAA,MACpB,OAAO;AAAA,MACP;AAAA,IACD;AACA,aAAS;AAAA,MACR,YAAY,OAAO;AAAA,MACnB,QAAQ,aAAa;AAAA,MACrB,eAAe,aAAa;AAAA,IAC7B;AAAA,EACD;AAEA,QAAM,UAAU,IAAI,iCAAkB,QAAQ,SAAS,QAAQ,EAAE,OAAO,CAAC;AACzE,QAAM,KAAK,IAAI,mBAAmB,QAAQ,SAAS,SAAS,MAAM;AAClE,EAAO,GAAI,UAAU;AAErB,SAAO;AACR;","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../../src/expo-sqlite/driver.ts"],"sourcesContent":["import type { SQLiteDatabase, SQLiteRunResult } from 'expo-sqlite';\nimport { entityKind } from '~/entity.ts';\nimport { DefaultLogger } from '~/logger.ts';\nimport {\n\tcreateTableRelationsHelpers,\n\textractTablesRelationalConfig,\n\ttype RelationalSchemaConfig,\n\ttype TablesRelationalConfig,\n} from '~/relations.ts';\nimport { BaseSQLiteDatabase } from '~/sqlite-core/db.ts';\nimport { SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport type { DrizzleConfig } from '~/utils.ts';\nimport { ExpoSQLiteSession } from './session.ts';\n\nexport class ExpoSQLiteDatabase<TSchema extends Record<string, unknown> = Record<string, never>>\n\textends BaseSQLiteDatabase<'sync', SQLiteRunResult, TSchema>\n{\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteDatabase';\n}\n\nexport function drizzle<TSchema extends Record<string, unknown> = Record<string, never>>(\n\tclient: SQLiteDatabase,\n\tconfig: DrizzleConfig<TSchema> = {},\n): ExpoSQLiteDatabase<TSchema> & {\n\t$client: SQLiteDatabase;\n} {\n\tconst dialect = new SQLiteSyncDialect({ casing: config.casing });\n\tlet logger;\n\tif (config.logger === true) {\n\t\tlogger = new DefaultLogger();\n\t} else if (config.logger !== false) {\n\t\tlogger = config.logger;\n\t}\n\n\tlet schema: RelationalSchemaConfig<TablesRelationalConfig> | undefined;\n\tif (config.schema) {\n\t\tconst tablesConfig = extractTablesRelationalConfig(\n\t\t\tconfig.schema,\n\t\t\tcreateTableRelationsHelpers,\n\t\t);\n\t\tschema = {\n\t\t\tfullSchema: config.schema,\n\t\t\tschema: tablesConfig.tables,\n\t\t\ttableNamesMap: tablesConfig.tableNamesMap,\n\t\t};\n\t}\n\n\tconst session = new ExpoSQLiteSession(client, dialect, schema, { logger });\n\tconst db = new ExpoSQLiteDatabase('sync', dialect, session, schema) as ExpoSQLiteDatabase<TSchema>;\n\t(<any> db).$client = client;\n\n\treturn db as any;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,oBAA2B;AAC3B,oBAA8B;AAC9B,uBAKO;AACP,gBAAmC;AACnC,qBAAkC;AAElC,qBAAkC;AAE3B,MAAM,2BACJ,6BACT;AAAA,EACC,QAA0B,wBAAU,IAAY;AACjD;AAEO,SAAS,QACf,QACA,SAAiC,CAAC,GAGjC;AACD,QAAM,UAAU,IAAI,iCAAkB,EAAE,QAAQ,OAAO,OAAO,CAAC;AAC/D,MAAI;AACJ,MAAI,OAAO,WAAW,MAAM;AAC3B,aAAS,IAAI,4BAAc;AAAA,EAC5B,WAAW,OAAO,WAAW,OAAO;AACnC,aAAS,OAAO;AAAA,EACjB;AAEA,MAAI;AACJ,MAAI,OAAO,QAAQ;AAClB,UAAM,mBAAe;AAAA,MACpB,OAAO;AAAA,MACP;AAAA,IACD;AACA,aAAS;AAAA,MACR,YAAY,OAAO;AAAA,MACnB,QAAQ,aAAa;AAAA,MACrB,eAAe,aAAa;AAAA,IAC7B;AAAA,EACD;AAEA,QAAM,UAAU,IAAI,iCAAkB,QAAQ,SAAS,QAAQ,EAAE,OAAO,CAAC;AACzE,QAAM,KAAK,IAAI,mBAAmB,QAAQ,SAAS,SAAS,MAAM;AAClE,EAAO,GAAI,UAAU;AAErB,SAAO;AACR;","names":[]}
diff --git a/expo-sqlite/driver.d.cts b/expo-sqlite/driver.d.cts
index fc9a98f69c0ab2950011ba6e8d7af6b8edacc2dc..8e52afe83eca11a4a8f911959f9e9f1ea98b2ce6 100644
--- a/expo-sqlite/driver.d.cts
+++ b/expo-sqlite/driver.d.cts
@@ -1,4 +1,4 @@
-import type { SQLiteDatabase, SQLiteRunResult } from 'expo-sqlite/next';
+import type { SQLiteDatabase, SQLiteRunResult } from 'expo-sqlite';
 import { entityKind } from "../entity.cjs";
 import { BaseSQLiteDatabase } from "../sqlite-core/db.cjs";
 import type { DrizzleConfig } from "../utils.cjs";
diff --git a/expo-sqlite/driver.d.ts b/expo-sqlite/driver.d.ts
index abddcba1956a620df62d686fa3a67343f19412f7..f5a2e457dbb001dc3e1a709f3de22f645f287773 100644
--- a/expo-sqlite/driver.d.ts
+++ b/expo-sqlite/driver.d.ts
@@ -1,4 +1,4 @@
-import type { SQLiteDatabase, SQLiteRunResult } from 'expo-sqlite/next';
+import type { SQLiteDatabase, SQLiteRunResult } from 'expo-sqlite';
 import { entityKind } from "../entity.js";
 import { BaseSQLiteDatabase } from "../sqlite-core/db.js";
 import type { DrizzleConfig } from "../utils.js";
diff --git a/expo-sqlite/driver.js.map b/expo-sqlite/driver.js.map
index 69f315ce69fdb4312884016c11dbba4863471ba2..17d40a7305aca709e2d6d72fdefce7ab3321f479 100644
--- a/expo-sqlite/driver.js.map
+++ b/expo-sqlite/driver.js.map
@@ -1 +1,11 @@
-{"version":3,"sources":["../../src/expo-sqlite/driver.ts"],"sourcesContent":["import type { SQLiteDatabase, SQLiteRunResult } from 'expo-sqlite/next';\nimport { entityKind } from '~/entity.ts';\nimport { DefaultLogger } from '~/logger.ts';\nimport {\n\tcreateTableRelationsHelpers,\n\textractTablesRelationalConfig,\n\ttype RelationalSchemaConfig,\n\ttype TablesRelationalConfig,\n} from '~/relations.ts';\nimport { BaseSQLiteDatabase } from '~/sqlite-core/db.ts';\nimport { SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport type { DrizzleConfig } from '~/utils.ts';\nimport { ExpoSQLiteSession } from './session.ts';\n\nexport class ExpoSQLiteDatabase<TSchema extends Record<string, unknown> = Record<string, never>>\n\textends BaseSQLiteDatabase<'sync', SQLiteRunResult, TSchema>\n{\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteDatabase';\n}\n\nexport function drizzle<TSchema extends Record<string, unknown> = Record<string, never>>(\n\tclient: SQLiteDatabase,\n\tconfig: DrizzleConfig<TSchema> = {},\n): ExpoSQLiteDatabase<TSchema> & {\n\t$client: SQLiteDatabase;\n} {\n\tconst dialect = new SQLiteSyncDialect({ casing: config.casing });\n\tlet logger;\n\tif (config.logger === true) {\n\t\tlogger = new DefaultLogger();\n\t} else if (config.logger !== false) {\n\t\tlogger = config.logger;\n\t}\n\n\tlet schema: RelationalSchemaConfig<TablesRelationalConfig> | undefined;\n\tif (config.schema) {\n\t\tconst tablesConfig = extractTablesRelationalConfig(\n\t\t\tconfig.schema,\n\t\t\tcreateTableRelationsHelpers,\n\t\t);\n\t\tschema = {\n\t\t\tfullSchema: config.schema,\n\t\t\tschema: tablesConfig.tables,\n\t\t\ttableNamesMap: tablesConfig.tableNamesMap,\n\t\t};\n\t}\n\n\tconst session = new ExpoSQLiteSession(client, dialect, schema, { logger });\n\tconst db = new ExpoSQLiteDatabase('sync', dialect, session, schema) as ExpoSQLiteDatabase<TSchema>;\n\t(<any> db).$client = client;\n\n\treturn db as any;\n}\n"],"mappings":"AACA,SAAS,kBAAkB;AAC3B,SAAS,qBAAqB;AAC9B;AAAA,EACC;AAAA,EACA;AAAA,OAGM;AACP,SAAS,0BAA0B;AACnC,SAAS,yBAAyB;AAElC,SAAS,yBAAyB;AAE3B,MAAM,2BACJ,mBACT;AAAA,EACC,QAA0B,UAAU,IAAY;AACjD;AAEO,SAAS,QACf,QACA,SAAiC,CAAC,GAGjC;AACD,QAAM,UAAU,IAAI,kBAAkB,EAAE,QAAQ,OAAO,OAAO,CAAC;AAC/D,MAAI;AACJ,MAAI,OAAO,WAAW,MAAM;AAC3B,aAAS,IAAI,cAAc;AAAA,EAC5B,WAAW,OAAO,WAAW,OAAO;AACnC,aAAS,OAAO;AAAA,EACjB;AAEA,MAAI;AACJ,MAAI,OAAO,QAAQ;AAClB,UAAM,eAAe;AAAA,MACpB,OAAO;AAAA,MACP;AAAA,IACD;AACA,aAAS;AAAA,MACR,YAAY,OAAO;AAAA,MACnB,QAAQ,aAAa;AAAA,MACrB,eAAe,aAAa;AAAA,IAC7B;AAAA,EACD;AAEA,QAAM,UAAU,IAAI,kBAAkB,QAAQ,SAAS,QAAQ,EAAE,OAAO,CAAC;AACzE,QAAM,KAAK,IAAI,mBAAmB,QAAQ,SAAS,SAAS,MAAM;AAClE,EAAO,GAAI,UAAU;AAErB,SAAO;AACR;","names":[]}
\ No newline at end of file
+{
+  "version": 3,
+  "sources": [
+    "../../src/expo-sqlite/driver.ts"
+  ],
+  "sourcesContent": [
+    "import type { SQLiteDatabase, SQLiteRunResult } from 'expo-sqlite';\nimport { entityKind } from '~/entity.ts';\nimport { DefaultLogger } from '~/logger.ts';\nimport {\n\tcreateTableRelationsHelpers,\n\textractTablesRelationalConfig,\n\ttype RelationalSchemaConfig,\n\ttype TablesRelationalConfig,\n} from '~/relations.ts';\nimport { BaseSQLiteDatabase } from '~/sqlite-core/db.ts';\nimport { SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport type { DrizzleConfig } from '~/utils.ts';\nimport { ExpoSQLiteSession } from './session.ts';\n\nexport class ExpoSQLiteDatabase<TSchema extends Record<string, unknown> = Record<string, never>>\n\textends BaseSQLiteDatabase<'sync', SQLiteRunResult, TSchema>\n{\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteDatabase';\n}\n\nexport function drizzle<TSchema extends Record<string, unknown> = Record<string, never>>(\n\tclient: SQLiteDatabase,\n\tconfig: DrizzleConfig<TSchema> = {},\n): ExpoSQLiteDatabase<TSchema> & {\n\t$client: SQLiteDatabase;\n} {\n\tconst dialect = new SQLiteSyncDialect({ casing: config.casing });\n\tlet logger;\n\tif (config.logger === true) {\n\t\tlogger = new DefaultLogger();\n\t} else if (config.logger !== false) {\n\t\tlogger = config.logger;\n\t}\n\n\tlet schema: RelationalSchemaConfig<TablesRelationalConfig> | undefined;\n\tif (config.schema) {\n\t\tconst tablesConfig = extractTablesRelationalConfig(\n\t\t\tconfig.schema,\n\t\t\tcreateTableRelationsHelpers,\n\t\t);\n\t\tschema = {\n\t\t\tfullSchema: config.schema,\n\t\t\tschema: tablesConfig.tables,\n\t\t\ttableNamesMap: tablesConfig.tableNamesMap,\n\t\t};\n\t}\n\n\tconst session = new ExpoSQLiteSession(client, dialect, schema, { logger });\n\tconst db = new ExpoSQLiteDatabase('sync', dialect, session, schema) as ExpoSQLiteDatabase<TSchema>;\n\t(<any> db).$client = client;\n\n\treturn db as any;\n}\n"
+  ],
+  "mappings": "AACA,SAAS,kBAAkB;AAC3B,SAAS,qBAAqB;AAC9B;AAAA,EACC;AAAA,EACA;AAAA,OAGM;AACP,SAAS,0BAA0B;AACnC,SAAS,yBAAyB;AAElC,SAAS,yBAAyB;AAE3B,MAAM,2BACJ,mBACT;AAAA,EACC,QAA0B,UAAU,IAAY;AACjD;AAEO,SAAS,QACf,QACA,SAAiC,CAAC,GAGjC;AACD,QAAM,UAAU,IAAI,kBAAkB,EAAE,QAAQ,OAAO,OAAO,CAAC;AAC/D,MAAI;AACJ,MAAI,OAAO,WAAW,MAAM;AAC3B,aAAS,IAAI,cAAc;AAAA,EAC5B,WAAW,OAAO,WAAW,OAAO;AACnC,aAAS,OAAO;AAAA,EACjB;AAEA,MAAI;AACJ,MAAI,OAAO,QAAQ;AAClB,UAAM,eAAe;AAAA,MACpB,OAAO;AAAA,MACP;AAAA,IACD;AACA,aAAS;AAAA,MACR,YAAY,OAAO;AAAA,MACnB,QAAQ,aAAa;AAAA,MACrB,eAAe,aAAa;AAAA,IAC7B;AAAA,EACD;AAEA,QAAM,UAAU,IAAI,kBAAkB,QAAQ,SAAS,QAAQ,EAAE,OAAO,CAAC;AACzE,QAAM,KAAK,IAAI,mBAAmB,QAAQ,SAAS,SAAS,MAAM;AAClE,EAAO,GAAI,UAAU;AAErB,SAAO;AACR;",
+  "names": []
+}
diff --git a/expo-sqlite/query.cjs b/expo-sqlite/query.cjs
index 216180a5a196ac85570aa7d7574efd7fbb8b8bc9..06eac7211c73fdf3094664218203de414460b795 100644
--- a/expo-sqlite/query.cjs
+++ b/expo-sqlite/query.cjs
@@ -21,7 +21,7 @@ __export(query_exports, {
   useLiveQuery: () => useLiveQuery
 });
 module.exports = __toCommonJS(query_exports);
-var import_next = require("expo-sqlite/next");
+var import_next = require("expo-sqlite");
 var import_react = require("react");
 var import_entity = require("../entity.cjs");
 var import_sql = require("../sql/sql.cjs");
diff --git a/expo-sqlite/query.cjs.map b/expo-sqlite/query.cjs.map
index 287dc7c54d4aa7363d60441ed76892892b1e902d..58242d8db3dc6b7b666d30d1afb45c42e3244909 100644
--- a/expo-sqlite/query.cjs.map
+++ b/expo-sqlite/query.cjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/expo-sqlite/query.ts"],"sourcesContent":["import { addDatabaseChangeListener } from 'expo-sqlite/next';\nimport { useEffect, useState } from 'react';\nimport { is } from '~/entity.ts';\nimport { SQL } from '~/sql/sql.ts';\nimport type { AnySQLiteSelect } from '~/sqlite-core/index.ts';\nimport { getTableConfig, getViewConfig, SQLiteTable, SQLiteView } from '~/sqlite-core/index.ts';\nimport { SQLiteRelationalQuery } from '~/sqlite-core/query-builders/query.ts';\nimport { Subquery } from '~/subquery.ts';\n\nexport const useLiveQuery = <T extends Pick<AnySQLiteSelect, '_' | 'then'> | SQLiteRelationalQuery<'sync', unknown>>(\n\tquery: T,\n\tdeps: unknown[] = [],\n) => {\n\tconst [data, setData] = useState<Awaited<T>>(\n\t\t(is(query, SQLiteRelationalQuery) && query.mode === 'first' ? undefined : []) as Awaited<T>,\n\t);\n\tconst [error, setError] = useState<Error>();\n\tconst [updatedAt, setUpdatedAt] = useState<Date>();\n\n\tuseEffect(() => {\n\t\tconst entity = is(query, SQLiteRelationalQuery) ? query.table : (query as AnySQLiteSelect).config.table;\n\n\t\tif (is(entity, Subquery) || is(entity, SQL)) {\n\t\t\tsetError(new Error('Selecting from subqueries and SQL are not supported in useLiveQuery'));\n\t\t\treturn;\n\t\t}\n\n\t\tlet listener: ReturnType<typeof addDatabaseChangeListener> | undefined;\n\n\t\tconst handleData = (data: any) => {\n\t\t\tsetData(data);\n\t\t\tsetUpdatedAt(new Date());\n\t\t};\n\n\t\tquery.then(handleData).catch(setError);\n\n\t\tif (is(entity, SQLiteTable) || is(entity, SQLiteView)) {\n\t\t\tconst config = is(entity, SQLiteTable) ? getTableConfig(entity) : getViewConfig(entity);\n\t\t\tlistener = addDatabaseChangeListener(({ tableName }) => {\n\t\t\t\tif (config.name === tableName) {\n\t\t\t\t\tquery.then(handleData).catch(setError);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn () => {\n\t\t\tlistener?.remove();\n\t\t};\n\t}, deps);\n\n\treturn {\n\t\tdata,\n\t\terror,\n\t\tupdatedAt,\n\t} as const;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAA0C;AAC1C,mBAAoC;AACpC,oBAAmB;AACnB,iBAAoB;AAEpB,yBAAuE;AACvE,mBAAsC;AACtC,sBAAyB;AAElB,MAAM,eAAe,CAC3B,OACA,OAAkB,CAAC,MACf;AACJ,QAAM,CAAC,MAAM,OAAO,QAAI;AAAA,QACtB,kBAAG,OAAO,kCAAqB,KAAK,MAAM,SAAS,UAAU,SAAY,CAAC;AAAA,EAC5E;AACA,QAAM,CAAC,OAAO,QAAQ,QAAI,uBAAgB;AAC1C,QAAM,CAAC,WAAW,YAAY,QAAI,uBAAe;AAEjD,8BAAU,MAAM;AACf,UAAM,aAAS,kBAAG,OAAO,kCAAqB,IAAI,MAAM,QAAS,MAA0B,OAAO;AAElG,YAAI,kBAAG,QAAQ,wBAAQ,SAAK,kBAAG,QAAQ,cAAG,GAAG;AAC5C,eAAS,IAAI,MAAM,qEAAqE,CAAC;AACzF;AAAA,IACD;AAEA,QAAI;AAEJ,UAAM,aAAa,CAACA,UAAc;AACjC,cAAQA,KAAI;AACZ,mBAAa,oBAAI,KAAK,CAAC;AAAA,IACxB;AAEA,UAAM,KAAK,UAAU,EAAE,MAAM,QAAQ;AAErC,YAAI,kBAAG,QAAQ,8BAAW,SAAK,kBAAG,QAAQ,6BAAU,GAAG;AACtD,YAAM,aAAS,kBAAG,QAAQ,8BAAW,QAAI,mCAAe,MAAM,QAAI,kCAAc,MAAM;AACtF,qBAAW,uCAA0B,CAAC,EAAE,UAAU,MAAM;AACvD,YAAI,OAAO,SAAS,WAAW;AAC9B,gBAAM,KAAK,UAAU,EAAE,MAAM,QAAQ;AAAA,QACtC;AAAA,MACD,CAAC;AAAA,IACF;AAEA,WAAO,MAAM;AACZ,gBAAU,OAAO;AAAA,IAClB;AAAA,EACD,GAAG,IAAI;AAEP,SAAO;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;","names":["data"]}
\ No newline at end of file
+{"version":3,"sources":["../../src/expo-sqlite/query.ts"],"sourcesContent":["import { addDatabaseChangeListener } from 'expo-sqlite';\nimport { useEffect, useState } from 'react';\nimport { is } from '~/entity.ts';\nimport { SQL } from '~/sql/sql.ts';\nimport type { AnySQLiteSelect } from '~/sqlite-core/index.ts';\nimport { getTableConfig, getViewConfig, SQLiteTable, SQLiteView } from '~/sqlite-core/index.ts';\nimport { SQLiteRelationalQuery } from '~/sqlite-core/query-builders/query.ts';\nimport { Subquery } from '~/subquery.ts';\n\nexport const useLiveQuery = <T extends Pick<AnySQLiteSelect, '_' | 'then'> | SQLiteRelationalQuery<'sync', unknown>>(\n\tquery: T,\n\tdeps: unknown[] = [],\n) => {\n\tconst [data, setData] = useState<Awaited<T>>(\n\t\t(is(query, SQLiteRelationalQuery) && query.mode === 'first' ? undefined : []) as Awaited<T>,\n\t);\n\tconst [error, setError] = useState<Error>();\n\tconst [updatedAt, setUpdatedAt] = useState<Date>();\n\n\tuseEffect(() => {\n\t\tconst entity = is(query, SQLiteRelationalQuery) ? query.table : (query as AnySQLiteSelect).config.table;\n\n\t\tif (is(entity, Subquery) || is(entity, SQL)) {\n\t\t\tsetError(new Error('Selecting from subqueries and SQL are not supported in useLiveQuery'));\n\t\t\treturn;\n\t\t}\n\n\t\tlet listener: ReturnType<typeof addDatabaseChangeListener> | undefined;\n\n\t\tconst handleData = (data: any) => {\n\t\t\tsetData(data);\n\t\t\tsetUpdatedAt(new Date());\n\t\t};\n\n\t\tquery.then(handleData).catch(setError);\n\n\t\tif (is(entity, SQLiteTable) || is(entity, SQLiteView)) {\n\t\t\tconst config = is(entity, SQLiteTable) ? getTableConfig(entity) : getViewConfig(entity);\n\t\t\tlistener = addDatabaseChangeListener(({ tableName }) => {\n\t\t\t\tif (config.name === tableName) {\n\t\t\t\t\tquery.then(handleData).catch(setError);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn () => {\n\t\t\tlistener?.remove();\n\t\t};\n\t}, deps);\n\n\treturn {\n\t\tdata,\n\t\terror,\n\t\tupdatedAt,\n\t} as const;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAA0C;AAC1C,mBAAoC;AACpC,oBAAmB;AACnB,iBAAoB;AAEpB,yBAAuE;AACvE,mBAAsC;AACtC,sBAAyB;AAElB,MAAM,eAAe,CAC3B,OACA,OAAkB,CAAC,MACf;AACJ,QAAM,CAAC,MAAM,OAAO,QAAI;AAAA,QACtB,kBAAG,OAAO,kCAAqB,KAAK,MAAM,SAAS,UAAU,SAAY,CAAC;AAAA,EAC5E;AACA,QAAM,CAAC,OAAO,QAAQ,QAAI,uBAAgB;AAC1C,QAAM,CAAC,WAAW,YAAY,QAAI,uBAAe;AAEjD,8BAAU,MAAM;AACf,UAAM,aAAS,kBAAG,OAAO,kCAAqB,IAAI,MAAM,QAAS,MAA0B,OAAO;AAElG,YAAI,kBAAG,QAAQ,wBAAQ,SAAK,kBAAG,QAAQ,cAAG,GAAG;AAC5C,eAAS,IAAI,MAAM,qEAAqE,CAAC;AACzF;AAAA,IACD;AAEA,QAAI;AAEJ,UAAM,aAAa,CAACA,UAAc;AACjC,cAAQA,KAAI;AACZ,mBAAa,oBAAI,KAAK,CAAC;AAAA,IACxB;AAEA,UAAM,KAAK,UAAU,EAAE,MAAM,QAAQ;AAErC,YAAI,kBAAG,QAAQ,8BAAW,SAAK,kBAAG,QAAQ,6BAAU,GAAG;AACtD,YAAM,aAAS,kBAAG,QAAQ,8BAAW,QAAI,mCAAe,MAAM,QAAI,kCAAc,MAAM;AACtF,qBAAW,uCAA0B,CAAC,EAAE,UAAU,MAAM;AACvD,YAAI,OAAO,SAAS,WAAW;AAC9B,gBAAM,KAAK,UAAU,EAAE,MAAM,QAAQ;AAAA,QACtC;AAAA,MACD,CAAC;AAAA,IACF;AAEA,WAAO,MAAM;AACZ,gBAAU,OAAO;AAAA,IAClB;AAAA,EACD,GAAG,IAAI;AAEP,SAAO;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;","names":["data"]}
diff --git a/expo-sqlite/query.js b/expo-sqlite/query.js
index 70f726731dc44052cc73ea158894ee84e357ab10..8352d554ec84de90ace25f0d23cfdec55c941d37 100644
--- a/expo-sqlite/query.js
+++ b/expo-sqlite/query.js
@@ -1,4 +1,4 @@
-import { addDatabaseChangeListener } from "expo-sqlite/next";
+import { addDatabaseChangeListener } from "expo-sqlite";
 import { useEffect, useState } from "react";
 import { is } from "../entity.js";
 import { SQL } from "../sql/sql.js";
diff --git a/expo-sqlite/query.js.map b/expo-sqlite/query.js.map
index 551b8d5c84bc1821ee4a7b8a7ba28703c746903b..8571726eab5e9f059669b9ac3d8c80be2e840f94 100644
--- a/expo-sqlite/query.js.map
+++ b/expo-sqlite/query.js.map
@@ -1 +1,13 @@
-{"version":3,"sources":["../../src/expo-sqlite/query.ts"],"sourcesContent":["import { addDatabaseChangeListener } from 'expo-sqlite/next';\nimport { useEffect, useState } from 'react';\nimport { is } from '~/entity.ts';\nimport { SQL } from '~/sql/sql.ts';\nimport type { AnySQLiteSelect } from '~/sqlite-core/index.ts';\nimport { getTableConfig, getViewConfig, SQLiteTable, SQLiteView } from '~/sqlite-core/index.ts';\nimport { SQLiteRelationalQuery } from '~/sqlite-core/query-builders/query.ts';\nimport { Subquery } from '~/subquery.ts';\n\nexport const useLiveQuery = <T extends Pick<AnySQLiteSelect, '_' | 'then'> | SQLiteRelationalQuery<'sync', unknown>>(\n\tquery: T,\n\tdeps: unknown[] = [],\n) => {\n\tconst [data, setData] = useState<Awaited<T>>(\n\t\t(is(query, SQLiteRelationalQuery) && query.mode === 'first' ? undefined : []) as Awaited<T>,\n\t);\n\tconst [error, setError] = useState<Error>();\n\tconst [updatedAt, setUpdatedAt] = useState<Date>();\n\n\tuseEffect(() => {\n\t\tconst entity = is(query, SQLiteRelationalQuery) ? query.table : (query as AnySQLiteSelect).config.table;\n\n\t\tif (is(entity, Subquery) || is(entity, SQL)) {\n\t\t\tsetError(new Error('Selecting from subqueries and SQL are not supported in useLiveQuery'));\n\t\t\treturn;\n\t\t}\n\n\t\tlet listener: ReturnType<typeof addDatabaseChangeListener> | undefined;\n\n\t\tconst handleData = (data: any) => {\n\t\t\tsetData(data);\n\t\t\tsetUpdatedAt(new Date());\n\t\t};\n\n\t\tquery.then(handleData).catch(setError);\n\n\t\tif (is(entity, SQLiteTable) || is(entity, SQLiteView)) {\n\t\t\tconst config = is(entity, SQLiteTable) ? getTableConfig(entity) : getViewConfig(entity);\n\t\t\tlistener = addDatabaseChangeListener(({ tableName }) => {\n\t\t\t\tif (config.name === tableName) {\n\t\t\t\t\tquery.then(handleData).catch(setError);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn () => {\n\t\t\tlistener?.remove();\n\t\t};\n\t}, deps);\n\n\treturn {\n\t\tdata,\n\t\terror,\n\t\tupdatedAt,\n\t} as const;\n};\n"],"mappings":"AAAA,SAAS,iCAAiC;AAC1C,SAAS,WAAW,gBAAgB;AACpC,SAAS,UAAU;AACnB,SAAS,WAAW;AAEpB,SAAS,gBAAgB,eAAe,aAAa,kBAAkB;AACvE,SAAS,6BAA6B;AACtC,SAAS,gBAAgB;AAElB,MAAM,eAAe,CAC3B,OACA,OAAkB,CAAC,MACf;AACJ,QAAM,CAAC,MAAM,OAAO,IAAI;AAAA,IACtB,GAAG,OAAO,qBAAqB,KAAK,MAAM,SAAS,UAAU,SAAY,CAAC;AAAA,EAC5E;AACA,QAAM,CAAC,OAAO,QAAQ,IAAI,SAAgB;AAC1C,QAAM,CAAC,WAAW,YAAY,IAAI,SAAe;AAEjD,YAAU,MAAM;AACf,UAAM,SAAS,GAAG,OAAO,qBAAqB,IAAI,MAAM,QAAS,MAA0B,OAAO;AAElG,QAAI,GAAG,QAAQ,QAAQ,KAAK,GAAG,QAAQ,GAAG,GAAG;AAC5C,eAAS,IAAI,MAAM,qEAAqE,CAAC;AACzF;AAAA,IACD;AAEA,QAAI;AAEJ,UAAM,aAAa,CAACA,UAAc;AACjC,cAAQA,KAAI;AACZ,mBAAa,oBAAI,KAAK,CAAC;AAAA,IACxB;AAEA,UAAM,KAAK,UAAU,EAAE,MAAM,QAAQ;AAErC,QAAI,GAAG,QAAQ,WAAW,KAAK,GAAG,QAAQ,UAAU,GAAG;AACtD,YAAM,SAAS,GAAG,QAAQ,WAAW,IAAI,eAAe,MAAM,IAAI,cAAc,MAAM;AACtF,iBAAW,0BAA0B,CAAC,EAAE,UAAU,MAAM;AACvD,YAAI,OAAO,SAAS,WAAW;AAC9B,gBAAM,KAAK,UAAU,EAAE,MAAM,QAAQ;AAAA,QACtC;AAAA,MACD,CAAC;AAAA,IACF;AAEA,WAAO,MAAM;AACZ,gBAAU,OAAO;AAAA,IAClB;AAAA,EACD,GAAG,IAAI;AAEP,SAAO;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;","names":["data"]}
\ No newline at end of file
+{
+  "version": 3,
+  "sources": [
+    "../../src/expo-sqlite/query.ts"
+  ],
+  "sourcesContent": [
+    "import { addDatabaseChangeListener } from 'expo-sqlite';\nimport { useEffect, useState } from 'react';\nimport { is } from '~/entity.ts';\nimport { SQL } from '~/sql/sql.ts';\nimport type { AnySQLiteSelect } from '~/sqlite-core/index.ts';\nimport { getTableConfig, getViewConfig, SQLiteTable, SQLiteView } from '~/sqlite-core/index.ts';\nimport { SQLiteRelationalQuery } from '~/sqlite-core/query-builders/query.ts';\nimport { Subquery } from '~/subquery.ts';\n\nexport const useLiveQuery = <T extends Pick<AnySQLiteSelect, '_' | 'then'> | SQLiteRelationalQuery<'sync', unknown>>(\n\tquery: T,\n\tdeps: unknown[] = [],\n) => {\n\tconst [data, setData] = useState<Awaited<T>>(\n\t\t(is(query, SQLiteRelationalQuery) && query.mode === 'first' ? undefined : []) as Awaited<T>,\n\t);\n\tconst [error, setError] = useState<Error>();\n\tconst [updatedAt, setUpdatedAt] = useState<Date>();\n\n\tuseEffect(() => {\n\t\tconst entity = is(query, SQLiteRelationalQuery) ? query.table : (query as AnySQLiteSelect).config.table;\n\n\t\tif (is(entity, Subquery) || is(entity, SQL)) {\n\t\t\tsetError(new Error('Selecting from subqueries and SQL are not supported in useLiveQuery'));\n\t\t\treturn;\n\t\t}\n\n\t\tlet listener: ReturnType<typeof addDatabaseChangeListener> | undefined;\n\n\t\tconst handleData = (data: any) => {\n\t\t\tsetData(data);\n\t\t\tsetUpdatedAt(new Date());\n\t\t};\n\n\t\tquery.then(handleData).catch(setError);\n\n\t\tif (is(entity, SQLiteTable) || is(entity, SQLiteView)) {\n\t\t\tconst config = is(entity, SQLiteTable) ? getTableConfig(entity) : getViewConfig(entity);\n\t\t\tlistener = addDatabaseChangeListener(({ tableName }) => {\n\t\t\t\tif (config.name === tableName) {\n\t\t\t\t\tquery.then(handleData).catch(setError);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn () => {\n\t\t\tlistener?.remove();\n\t\t};\n\t}, deps);\n\n\treturn {\n\t\tdata,\n\t\terror,\n\t\tupdatedAt,\n\t} as const;\n};\n"
+  ],
+  "mappings": "AAAA,SAAS,iCAAiC;AAC1C,SAAS,WAAW,gBAAgB;AACpC,SAAS,UAAU;AACnB,SAAS,WAAW;AAEpB,SAAS,gBAAgB,eAAe,aAAa,kBAAkB;AACvE,SAAS,6BAA6B;AACtC,SAAS,gBAAgB;AAElB,MAAM,eAAe,CAC3B,OACA,OAAkB,CAAC,MACf;AACJ,QAAM,CAAC,MAAM,OAAO,IAAI;AAAA,IACtB,GAAG,OAAO,qBAAqB,KAAK,MAAM,SAAS,UAAU,SAAY,CAAC;AAAA,EAC5E;AACA,QAAM,CAAC,OAAO,QAAQ,IAAI,SAAgB;AAC1C,QAAM,CAAC,WAAW,YAAY,IAAI,SAAe;AAEjD,YAAU,MAAM;AACf,UAAM,SAAS,GAAG,OAAO,qBAAqB,IAAI,MAAM,QAAS,MAA0B,OAAO;AAElG,QAAI,GAAG,QAAQ,QAAQ,KAAK,GAAG,QAAQ,GAAG,GAAG;AAC5C,eAAS,IAAI,MAAM,qEAAqE,CAAC;AACzF;AAAA,IACD;AAEA,QAAI;AAEJ,UAAM,aAAa,CAACA,UAAc;AACjC,cAAQA,KAAI;AACZ,mBAAa,oBAAI,KAAK,CAAC;AAAA,IACxB;AAEA,UAAM,KAAK,UAAU,EAAE,MAAM,QAAQ;AAErC,QAAI,GAAG,QAAQ,WAAW,KAAK,GAAG,QAAQ,UAAU,GAAG;AACtD,YAAM,SAAS,GAAG,QAAQ,WAAW,IAAI,eAAe,MAAM,IAAI,cAAc,MAAM;AACtF,iBAAW,0BAA0B,CAAC,EAAE,UAAU,MAAM;AACvD,YAAI,OAAO,SAAS,WAAW;AAC9B,gBAAM,KAAK,UAAU,EAAE,MAAM,QAAQ;AAAA,QACtC;AAAA,MACD,CAAC;AAAA,IACF;AAEA,WAAO,MAAM;AACZ,gBAAU,OAAO;AAAA,IAClB;AAAA,EACD,GAAG,IAAI;AAEP,SAAO;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA,EACD;AACD;",
+  "names": [
+    "data"
+  ]
+}
diff --git a/expo-sqlite/session.cjs.map b/expo-sqlite/session.cjs.map
index 9c9851491bea864aecbc990c8b4b0feb7264ace6..7aee5a1089ee0ea6d0a779269f3c95aa63152b3f 100644
--- a/expo-sqlite/session.cjs.map
+++ b/expo-sqlite/session.cjs.map
@@ -1 +1 @@
-{"version":3,"sources":["../../src/expo-sqlite/session.ts"],"sourcesContent":["import type { SQLiteDatabase, SQLiteRunResult, SQLiteStatement } from 'expo-sqlite/next';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport { fillPlaceholders, type Query, sql } from '~/sql/sql.ts';\nimport type { SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport {\n\ttype PreparedQueryConfig as PreparedQueryConfigBase,\n\ttype SQLiteExecuteMethod,\n\tSQLitePreparedQuery,\n\tSQLiteSession,\n\ttype SQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface ExpoSQLiteSessionOptions {\n\tlogger?: Logger;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class ExpoSQLiteSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteSession<'sync', SQLiteRunResult, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: SQLiteDatabase,\n\t\tdialect: SQLiteSyncDialect,\n\t\tprivate schema: RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: ExpoSQLiteSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t): ExpoSQLitePreparedQuery<T> {\n\t\tconst stmt = this.client.prepareSync(query.sql);\n\t\treturn new ExpoSQLitePreparedQuery(\n\t\t\tstmt,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: ExpoSQLiteTransaction<TFullSchema, TSchema>) => T,\n\t\tconfig: SQLiteTransactionConfig = {},\n\t): T {\n\t\tconst tx = new ExpoSQLiteTransaction('sync', this.dialect, this, this.schema);\n\t\tthis.run(sql.raw(`begin${config?.behavior ? ' ' + config.behavior : ''}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.run(sql`commit`);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.run(sql`rollback`);\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class ExpoSQLiteTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteTransaction<'sync', SQLiteRunResult, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteTransaction';\n\n\toverride transaction<T>(transaction: (tx: ExpoSQLiteTransaction<TFullSchema, TSchema>) => T): T {\n\t\tconst savepointName = `sp${this.nestedIndex}`;\n\t\tconst tx = new ExpoSQLiteTransaction('sync', this.dialect, this.session, this.schema, this.nestedIndex + 1);\n\t\tthis.session.run(sql.raw(`savepoint ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.session.run(sql.raw(`release savepoint ${savepointName}`));\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.session.run(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class ExpoSQLitePreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig> extends SQLitePreparedQuery<\n\t{ type: 'sync'; run: SQLiteRunResult; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLitePreparedQuery';\n\n\tconstructor(\n\t\tprivate stmt: SQLiteStatement,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (rows: unknown[][]) => unknown,\n\t) {\n\t\tsuper('sync', executeMethod, query);\n\t}\n\n\trun(placeholderValues?: Record<string, unknown>): SQLiteRunResult {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\tconst { changes, lastInsertRowId } = this.stmt.executeSync(params as any[]);\n\t\treturn {\n\t\t\tchanges,\n\t\t\tlastInsertRowId,\n\t\t};\n\t}\n\n\tall(placeholderValues?: Record<string, unknown>): T['all'] {\n\t\tconst { fields, joinsNotNullableMap, query, logger, stmt, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\t\t\treturn stmt.executeSync(params as any[]).getAllSync();\n\t\t}\n\n\t\tconst rows = this.values(placeholderValues) as unknown[][];\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['all'];\n\t\t}\n\t\treturn rows.map((row) => mapResultRow(fields!, row, joinsNotNullableMap));\n\t}\n\n\tget(placeholderValues?: Record<string, unknown>): T['get'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { fields, stmt, joinsNotNullableMap, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\treturn stmt.executeSync(params as any[]).getFirstSync();\n\t\t}\n\n\t\tconst rows = this.values(placeholderValues) as unknown[][];\n\t\tconst row = rows[0];\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['get'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, row, joinsNotNullableMap);\n\t}\n\n\tvalues(placeholderValues?: Record<string, unknown>): T['values'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.stmt.executeForRawResultSync(params as any[]).getAllSync();\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
+{"version":3,"sources":["../../src/expo-sqlite/session.ts"],"sourcesContent":["import type { SQLiteDatabase, SQLiteRunResult, SQLiteStatement } from 'expo-sqlite';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport { fillPlaceholders, type Query, sql } from '~/sql/sql.ts';\nimport type { SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport {\n\ttype PreparedQueryConfig as PreparedQueryConfigBase,\n\ttype SQLiteExecuteMethod,\n\tSQLitePreparedQuery,\n\tSQLiteSession,\n\ttype SQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface ExpoSQLiteSessionOptions {\n\tlogger?: Logger;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class ExpoSQLiteSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteSession<'sync', SQLiteRunResult, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: SQLiteDatabase,\n\t\tdialect: SQLiteSyncDialect,\n\t\tprivate schema: RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: ExpoSQLiteSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t): ExpoSQLitePreparedQuery<T> {\n\t\tconst stmt = this.client.prepareSync(query.sql);\n\t\treturn new ExpoSQLitePreparedQuery(\n\t\t\tstmt,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: ExpoSQLiteTransaction<TFullSchema, TSchema>) => T,\n\t\tconfig: SQLiteTransactionConfig = {},\n\t): T {\n\t\tconst tx = new ExpoSQLiteTransaction('sync', this.dialect, this, this.schema);\n\t\tthis.run(sql.raw(`begin${config?.behavior ? ' ' + config.behavior : ''}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.run(sql`commit`);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.run(sql`rollback`);\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class ExpoSQLiteTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteTransaction<'sync', SQLiteRunResult, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteTransaction';\n\n\toverride transaction<T>(transaction: (tx: ExpoSQLiteTransaction<TFullSchema, TSchema>) => T): T {\n\t\tconst savepointName = `sp${this.nestedIndex}`;\n\t\tconst tx = new ExpoSQLiteTransaction('sync', this.dialect, this.session, this.schema, this.nestedIndex + 1);\n\t\tthis.session.run(sql.raw(`savepoint ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.session.run(sql.raw(`release savepoint ${savepointName}`));\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.session.run(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class ExpoSQLitePreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig> extends SQLitePreparedQuery<\n\t{ type: 'sync'; run: SQLiteRunResult; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLitePreparedQuery';\n\n\tconstructor(\n\t\tprivate stmt: SQLiteStatement,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (rows: unknown[][]) => unknown,\n\t) {\n\t\tsuper('sync', executeMethod, query);\n\t}\n\n\trun(placeholderValues?: Record<string, unknown>): SQLiteRunResult {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\tconst { changes, lastInsertRowId } = this.stmt.executeSync(params as any[]);\n\t\treturn {\n\t\t\tchanges,\n\t\t\tlastInsertRowId,\n\t\t};\n\t}\n\n\tall(placeholderValues?: Record<string, unknown>): T['all'] {\n\t\tconst { fields, joinsNotNullableMap, query, logger, stmt, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\t\t\treturn stmt.executeSync(params as any[]).getAllSync();\n\t\t}\n\n\t\tconst rows = this.values(placeholderValues) as unknown[][];\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['all'];\n\t\t}\n\t\treturn rows.map((row) => mapResultRow(fields!, row, joinsNotNullableMap));\n\t}\n\n\tget(placeholderValues?: Record<string, unknown>): T['get'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { fields, stmt, joinsNotNullableMap, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\treturn stmt.executeSync(params as any[]).getFirstSync();\n\t\t}\n\n\t\tconst rows = this.values(placeholderValues) as unknown[][];\n\t\tconst row = rows[0];\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['get'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, row, joinsNotNullableMap);\n\t}\n\n\tvalues(placeholderValues?: Record<string, unknown>): T['values'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.stmt.executeForRawResultSync(params as any[]).getAllSync();\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n"],"mappings":"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","names":[]}
diff --git a/expo-sqlite/session.d.cts b/expo-sqlite/session.d.cts
index d1f1eed41f1d6bd0d21b577aa319f3fe5a0249e7..2e06f5e1584500e94c296387b56092c62f80fb80 100644
--- a/expo-sqlite/session.d.cts
+++ b/expo-sqlite/session.d.cts
@@ -1,4 +1,4 @@
-import type { SQLiteDatabase, SQLiteRunResult, SQLiteStatement } from 'expo-sqlite/next';
+import type { SQLiteDatabase, SQLiteRunResult, SQLiteStatement } from 'expo-sqlite';
 import { entityKind } from "../entity.cjs";
 import type { Logger } from "../logger.cjs";
 import type { RelationalSchemaConfig, TablesRelationalConfig } from "../relations.cjs";
@@ -44,4 +44,5 @@ export declare class ExpoSQLitePreparedQuery<T extends PreparedQueryConfig = Pre
     get(placeholderValues?: Record<string, unknown>): T['get'];
     values(placeholderValues?: Record<string, unknown>): T['values'];
 }
-export {};
+export { };
+
diff --git a/expo-sqlite/session.d.ts b/expo-sqlite/session.d.ts
index f125c50517278fe24eebc886195389aa1ab198c2..edbca9511651403c807dd9c1f8e1fb438c5217e9 100644
--- a/expo-sqlite/session.d.ts
+++ b/expo-sqlite/session.d.ts
@@ -1,4 +1,4 @@
-import type { SQLiteDatabase, SQLiteRunResult, SQLiteStatement } from 'expo-sqlite/next';
+import type { SQLiteDatabase, SQLiteRunResult, SQLiteStatement } from 'expo-sqlite';
 import { entityKind } from "../entity.js";
 import type { Logger } from "../logger.js";
 import type { RelationalSchemaConfig, TablesRelationalConfig } from "../relations.js";
@@ -44,4 +44,5 @@ export declare class ExpoSQLitePreparedQuery<T extends PreparedQueryConfig = Pre
     get(placeholderValues?: Record<string, unknown>): T['get'];
     values(placeholderValues?: Record<string, unknown>): T['values'];
 }
-export {};
+export { };
+
diff --git a/expo-sqlite/session.js.map b/expo-sqlite/session.js.map
index 1c6939262770632c2f10919e1589e7b62a2bbd4c..f856e411f752ce41e6ec4228505285b2aa14eb27 100644
--- a/expo-sqlite/session.js.map
+++ b/expo-sqlite/session.js.map
@@ -1 +1,11 @@
-{"version":3,"sources":["../../src/expo-sqlite/session.ts"],"sourcesContent":["import type { SQLiteDatabase, SQLiteRunResult, SQLiteStatement } from 'expo-sqlite/next';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport { fillPlaceholders, type Query, sql } from '~/sql/sql.ts';\nimport type { SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport {\n\ttype PreparedQueryConfig as PreparedQueryConfigBase,\n\ttype SQLiteExecuteMethod,\n\tSQLitePreparedQuery,\n\tSQLiteSession,\n\ttype SQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface ExpoSQLiteSessionOptions {\n\tlogger?: Logger;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class ExpoSQLiteSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteSession<'sync', SQLiteRunResult, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: SQLiteDatabase,\n\t\tdialect: SQLiteSyncDialect,\n\t\tprivate schema: RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: ExpoSQLiteSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t): ExpoSQLitePreparedQuery<T> {\n\t\tconst stmt = this.client.prepareSync(query.sql);\n\t\treturn new ExpoSQLitePreparedQuery(\n\t\t\tstmt,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: ExpoSQLiteTransaction<TFullSchema, TSchema>) => T,\n\t\tconfig: SQLiteTransactionConfig = {},\n\t): T {\n\t\tconst tx = new ExpoSQLiteTransaction('sync', this.dialect, this, this.schema);\n\t\tthis.run(sql.raw(`begin${config?.behavior ? ' ' + config.behavior : ''}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.run(sql`commit`);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.run(sql`rollback`);\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class ExpoSQLiteTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteTransaction<'sync', SQLiteRunResult, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteTransaction';\n\n\toverride transaction<T>(transaction: (tx: ExpoSQLiteTransaction<TFullSchema, TSchema>) => T): T {\n\t\tconst savepointName = `sp${this.nestedIndex}`;\n\t\tconst tx = new ExpoSQLiteTransaction('sync', this.dialect, this.session, this.schema, this.nestedIndex + 1);\n\t\tthis.session.run(sql.raw(`savepoint ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.session.run(sql.raw(`release savepoint ${savepointName}`));\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.session.run(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class ExpoSQLitePreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig> extends SQLitePreparedQuery<\n\t{ type: 'sync'; run: SQLiteRunResult; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLitePreparedQuery';\n\n\tconstructor(\n\t\tprivate stmt: SQLiteStatement,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (rows: unknown[][]) => unknown,\n\t) {\n\t\tsuper('sync', executeMethod, query);\n\t}\n\n\trun(placeholderValues?: Record<string, unknown>): SQLiteRunResult {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\tconst { changes, lastInsertRowId } = this.stmt.executeSync(params as any[]);\n\t\treturn {\n\t\t\tchanges,\n\t\t\tlastInsertRowId,\n\t\t};\n\t}\n\n\tall(placeholderValues?: Record<string, unknown>): T['all'] {\n\t\tconst { fields, joinsNotNullableMap, query, logger, stmt, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\t\t\treturn stmt.executeSync(params as any[]).getAllSync();\n\t\t}\n\n\t\tconst rows = this.values(placeholderValues) as unknown[][];\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['all'];\n\t\t}\n\t\treturn rows.map((row) => mapResultRow(fields!, row, joinsNotNullableMap));\n\t}\n\n\tget(placeholderValues?: Record<string, unknown>): T['get'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { fields, stmt, joinsNotNullableMap, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\treturn stmt.executeSync(params as any[]).getFirstSync();\n\t\t}\n\n\t\tconst rows = this.values(placeholderValues) as unknown[][];\n\t\tconst row = rows[0];\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['get'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, row, joinsNotNullableMap);\n\t}\n\n\tvalues(placeholderValues?: Record<string, unknown>): T['values'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.stmt.executeForRawResultSync(params as any[]).getAllSync();\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n"],"mappings":"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","names":[]}
\ No newline at end of file
+{
+  "version": 3,
+  "sources": [
+    "../../src/expo-sqlite/session.ts"
+  ],
+  "sourcesContent": [
+    "import type { SQLiteDatabase, SQLiteRunResult, SQLiteStatement } from 'expo-sqlite';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport { fillPlaceholders, type Query, sql } from '~/sql/sql.ts';\nimport type { SQLiteSyncDialect } from '~/sqlite-core/dialect.ts';\nimport { SQLiteTransaction } from '~/sqlite-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/sqlite-core/query-builders/select.types.ts';\nimport {\n\ttype PreparedQueryConfig as PreparedQueryConfigBase,\n\ttype SQLiteExecuteMethod,\n\tSQLitePreparedQuery,\n\tSQLiteSession,\n\ttype SQLiteTransactionConfig,\n} from '~/sqlite-core/session.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport interface ExpoSQLiteSessionOptions {\n\tlogger?: Logger;\n}\n\ntype PreparedQueryConfig = Omit<PreparedQueryConfigBase, 'statement' | 'run'>;\n\nexport class ExpoSQLiteSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteSession<'sync', SQLiteRunResult, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: SQLiteDatabase,\n\t\tdialect: SQLiteSyncDialect,\n\t\tprivate schema: RelationalSchemaConfig<TSchema> | undefined,\n\t\toptions: ExpoSQLiteSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends Omit<PreparedQueryConfig, 'run'>>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => unknown,\n\t): ExpoSQLitePreparedQuery<T> {\n\t\tconst stmt = this.client.prepareSync(query.sql);\n\t\treturn new ExpoSQLitePreparedQuery(\n\t\t\tstmt,\n\t\t\tquery,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\texecuteMethod,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: ExpoSQLiteTransaction<TFullSchema, TSchema>) => T,\n\t\tconfig: SQLiteTransactionConfig = {},\n\t): T {\n\t\tconst tx = new ExpoSQLiteTransaction('sync', this.dialect, this, this.schema);\n\t\tthis.run(sql.raw(`begin${config?.behavior ? ' ' + config.behavior : ''}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.run(sql`commit`);\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.run(sql`rollback`);\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class ExpoSQLiteTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends SQLiteTransaction<'sync', SQLiteRunResult, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLiteTransaction';\n\n\toverride transaction<T>(transaction: (tx: ExpoSQLiteTransaction<TFullSchema, TSchema>) => T): T {\n\t\tconst savepointName = `sp${this.nestedIndex}`;\n\t\tconst tx = new ExpoSQLiteTransaction('sync', this.dialect, this.session, this.schema, this.nestedIndex + 1);\n\t\tthis.session.run(sql.raw(`savepoint ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = transaction(tx);\n\t\t\tthis.session.run(sql.raw(`release savepoint ${savepointName}`));\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tthis.session.run(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport class ExpoSQLitePreparedQuery<T extends PreparedQueryConfig = PreparedQueryConfig> extends SQLitePreparedQuery<\n\t{ type: 'sync'; run: SQLiteRunResult; all: T['all']; get: T['get']; values: T['values']; execute: T['execute'] }\n> {\n\tstatic override readonly [entityKind]: string = 'ExpoSQLitePreparedQuery';\n\n\tconstructor(\n\t\tprivate stmt: SQLiteStatement,\n\t\tquery: Query,\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\texecuteMethod: SQLiteExecuteMethod,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (rows: unknown[][]) => unknown,\n\t) {\n\t\tsuper('sync', executeMethod, query);\n\t}\n\n\trun(placeholderValues?: Record<string, unknown>): SQLiteRunResult {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\tconst { changes, lastInsertRowId } = this.stmt.executeSync(params as any[]);\n\t\treturn {\n\t\t\tchanges,\n\t\t\tlastInsertRowId,\n\t\t};\n\t}\n\n\tall(placeholderValues?: Record<string, unknown>): T['all'] {\n\t\tconst { fields, joinsNotNullableMap, query, logger, stmt, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\tconst params = fillPlaceholders(query.params, placeholderValues ?? {});\n\t\t\tlogger.logQuery(query.sql, params);\n\t\t\treturn stmt.executeSync(params as any[]).getAllSync();\n\t\t}\n\n\t\tconst rows = this.values(placeholderValues) as unknown[][];\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['all'];\n\t\t}\n\t\treturn rows.map((row) => mapResultRow(fields!, row, joinsNotNullableMap));\n\t}\n\n\tget(placeholderValues?: Record<string, unknown>): T['get'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\n\t\tconst { fields, stmt, joinsNotNullableMap, customResultMapper } = this;\n\t\tif (!fields && !customResultMapper) {\n\t\t\treturn stmt.executeSync(params as any[]).getFirstSync();\n\t\t}\n\n\t\tconst rows = this.values(placeholderValues) as unknown[][];\n\t\tconst row = rows[0];\n\n\t\tif (!row) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (customResultMapper) {\n\t\t\treturn customResultMapper(rows) as T['get'];\n\t\t}\n\n\t\treturn mapResultRow(fields!, row, joinsNotNullableMap);\n\t}\n\n\tvalues(placeholderValues?: Record<string, unknown>): T['values'] {\n\t\tconst params = fillPlaceholders(this.query.params, placeholderValues ?? {});\n\t\tthis.logger.logQuery(this.query.sql, params);\n\t\treturn this.stmt.executeForRawResultSync(params as any[]).getAllSync();\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n"
+  ],
+  "mappings": "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",
+  "names": []
+}
